declare const BABYLON: any

import {
  Engine,
  type State,
  ARENA_WIDTH,
  ARENA_HEIGHT,
} from '../../lib/engine/index.js'

customElements.define(
  'ft-babylon',
  class extends HTMLElement {
    canvas: HTMLCanvasElement
    engine: any
    scene: any
    logicEngine: Engine

    meshes: {
      ball: any
      p1: any
      p2: any
    }

    constructor() {
      super()

      this.classList.add('grid', 'place-items-center')

      this.canvas = document.createElement('canvas')
      this.canvas.setAttribute('width', ARENA_WIDTH.toString())
      this.canvas.setAttribute('height', ARENA_HEIGHT.toString())
      this.canvas.classList.add('border')
      this.appendChild(this.canvas)

      this.engine = new BABYLON.Engine(this.canvas, true)
      this.scene = this.createScene()

      this.engine.runRenderLoop(() => {
        this.scene.render()
      })

      this.logicEngine = new Engine((state) => {
        this.updateScene(state)
      })
      this.logicEngine.startGame()

      document.addEventListener("keydown", (e) => {
        if (e.key === "w") this.logicEngine.setInput("p1", "up", true)
        if (e.key === "s") this.logicEngine.setInput("p1", "down", true)
        if (e.key === "ArrowUp") this.logicEngine.setInput("p2", "up", true)
        if (e.key === "ArrowDown") this.logicEngine.setInput("p2", "down", true)
      })

      document.addEventListener("keyup", (e) => {
        if (e.key === "w") this.logicEngine.setInput("p1", "up", false)
        if (e.key === "s") this.logicEngine.setInput("p1", "down", false)
        if (e.key === "ArrowUp") this.logicEngine.setInput("p2", "up", false)
        if (e.key === "ArrowDown") this.logicEngine.setInput("p2", "down", false)
      })
    }

    createScene() {
      const scene = new BABYLON.Scene(this.engine)

      // Caméra orthographique pour une vraie vue 2D
      const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 0, -100), scene)
      camera.setTarget(new BABYLON.Vector3(ARENA_WIDTH /60, 0, 0))
      camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA
      camera.orthoLeft = 0
      camera.orthoRight = ARENA_WIDTH
      camera.orthoTop = 0
      camera.orthoBottom = ARENA_HEIGHT

      // Lumière
      new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene)

      // Fond visible
      const ground = BABYLON.MeshBuilder.CreateGround("ground", {
        width: ARENA_WIDTH,
        height: ARENA_HEIGHT,
      }, scene)
      ground.position.z = -1

      this.meshes = {
        ball: BABYLON.MeshBuilder.CreateSphere("ball", { diameter: 12 }, scene),
        p1: BABYLON.MeshBuilder.CreateBox("p1", {
          width: ARENA_WIDTH / 60,
          height: ARENA_HEIGHT / 5,
          depth: 1,
        }, scene),
        p2: BABYLON.MeshBuilder.CreateBox("p2", {
          width: ARENA_WIDTH / 60,
          height: ARENA_HEIGHT / 5,
          depth: 1,
        }, scene),
      }

      return scene
    }

    updateScene(state: State) {
      const { ball, paddles } = state

      this.meshes.ball.position.x = ball.position.x + ball.size / 2
      this.meshes.ball.position.y = ball.position.y + ball.size / 2
      this.meshes.ball.position.z = 0

      this.meshes.p1.position.x = paddles.p1.position.x + paddles.p1.width / 2
      this.meshes.p1.position.y = paddles.p1.position.y + paddles.p1.height / 2
      this.meshes.p1.position.z = 0

      this.meshes.p2.position.x = paddles.p2.position.x + paddles.p2.width / 2
      this.meshes.p2.position.y = paddles.p2.position.y + paddles.p2.height / 2
      this.meshes.p2.position.z = 0
    }
  },
)

